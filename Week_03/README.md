学习笔记

本周学习内容：分治，回溯

二叉树寻找最近公共祖先的思路：
本题有两个思路
1，递归
     定义fx 表达式，左子树或者右子书是否包含p或者q节点，当前节点是否是p或者q节点，x为子节点
     深度优先便利，在便利中利用上述表达式找出答案。
 2，保存每个节点的父亲节点，通过map保存。从p向上跳一直到根，保存访问过的节点路径到set，然后再从q向上访问，如果有节点在set中，找到答案

105. 从前序与中序遍历序列构造二叉树
思路：从前序遍历的第一个元素确定根节点，用这个根节点在中序遍历中找到对应的下标
1）用这个下标在中序遍历中确定左子树的长度
2）用这个左子树的长度找出对应在 中序遍历 和 前序遍历的 左子树和右子树的起始和终止下标
    // 中序遍历的左子树：inOrderLeft   到   inOrderRootIndex - 1
    // 中序遍历的右子树：inOrderRootIndex + 1  到    inOrderRight
    // 前序遍历的左子树：preOrderLeft + 1  到  （preOrderLeft + 1 + sizeLeftSubtree -1）
    // 前序遍历的右子树：（preOrderLeft + 1 + sizeLeftSubtree -1） + 1 到 preOrderRight
    时间复杂度：O（n），n为树节点的数目
    空间复杂度：O（n），一个是存储哈希表，一个递归栈空间
    
    
77. 组合
思路：
   回溯：利用栈的回溯性，在递归前后使用
   剪枝：从规则中得出，不需要再添加数，从而现在循环中i的最大值
      规律 index的最大值 + 接下来要选择的元素的个数 - 1 = n, index的最大值的意思是有效的组合，即使之后再添加新数也无解了
      接下来要选择的元素的个数 = k - deque.size()
      
      
46. 全排列
思路：深度优先遍历，利用一个used数组记录是否已经用过，利用for循环便利

47. 全排列 II
思路：和46题相同，但是考虑的剪枝情况
    剪枝关键：1，如果之前的一个数和当前相等，但是刚刚从栈中取消的，则要剪枝。2，如果是正在使用中的，则要继续，不要剪，可以参考leecode上的一个图。
     即条件  i>0 && nums[i]==nums[i-1] && !used[i-1]   则  continue